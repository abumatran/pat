/**************************************************************************
 DictionaryAnalyser - Package based in DixTools and created to provide a set
               of tools that ease the addition of new entries to dictionaries
               and helps to analyse the dictionaries.

 Copyright (C) 2011-2012 Universitat d'Alacant [www.ua.es]

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 **************************************************************************/

package es.ua.dlsi.id3;

import es.ua.dlsi.monolingual.Candidate;
import es.ua.dlsi.monolingual.EquivalentCandidates;
import es.ua.dlsi.querying.GenericCandidateStructure;
import java.io.PrintWriter;
import java.util.*;

/**
 * Class that represents an ID3 decision tree. This class represents an ID3 
 * binary decision tree. This tree contains, in every node, a test attribute
 * (in this case, a surface form generated by a part of the candidates) and two
 * sub-nodes contain the sub-tree of candidates generating this surface forma nd
 * the sub-stree of candidates not generating this surface form. In the leaves
 * of the tree one can find a candidate stem/paradigm (or a collection of
 * candidates generating the same surface forms). This tree tries to choose, for
 * every node, the attribute splitting the two sub-trees in order balance as much
 * as possible the probability summation between the two sub-trees.
 * @author Miquel Espl√† Gomis
 */
public class Tree extends GenericCandidateStructure{
    
    /** Root node of the tree. */
    public Node root;
    
    /** Current position when going through the tree. */
    public Node current_position;
    
    /**
     * Overloaded constructor of the class that builds the tree from a set of
     * instances.
     * @param data Set of instances from which the tree is built
     */
    public Tree(InstanceCollection data){
        root=new Node();
        root.setData(data);
        buildTree(root);
        current_position=root;
    }
    
    /**
     * Recursive method that builds a sub-tree from a given node.
     * @param root Starting node for the new sub-tree
     */
    static private void buildTree(Node root) {
        int bestAttribute = -1;
        double bestGain = 0;
        InstanceCollection best_true_subset=null;
        InstanceCollection best_false_subset=null;
        if(root.getData().getInstances().size()==1){
            root.candidates=root.getData().getInstances().get(0).getInstanceClass();
        }
        else{
            root.setEntropy(Entropy.Entropy(root.getData()));

            for(int i = 0; i < root.getData().getNumSurfaceForms(); i++) {

                InstanceCollection subset_true = root.getData().subset(i, true);
                InstanceCollection subset_false = root.getData().subset(i, false);

                double root_probability_mass=Entropy.ProbabilityMass(root.getData());
                
                double gain = Entropy.calculateGain(root.getEntropy(),
                        root_probability_mass, subset_true, subset_false);

                if(gain > bestGain && !subset_true.isEmpty() && !subset_false.isEmpty()) {
                    bestAttribute = i;
                    bestGain = gain;
                    best_true_subset=subset_true;
                    best_false_subset=subset_false;
                }
            }
            if(bestAttribute != -1) {
                root.setTestAttribute(root.getData().getSurfaceForms().get(bestAttribute));
                root.true_children = new Node();
                root.true_children.setParent(root);
                root.true_children.setData(best_true_subset);

                root.false_children = new Node();
                root.false_children.setParent(root);
                root.false_children.setData(best_false_subset);
                buildTree(root.true_children);
                buildTree(root.false_children);
            }
        }
    }

    /**
     * Method that prints the ID3 tree.
     * @param pw PrintWriter object used to output the information
     */
    public void Print(PrintWriter pw){
        boolean empty=false;
        if(pw==null){
            empty=true;
            pw=new PrintWriter(System.out);
        }
        Set<String> candidates=new LinkedHashSet<String>();
        Set<String> nodes=new LinkedHashSet<String>();
        List<String> links=new LinkedList<String>();
        Stack<Node> stack=new Stack<Node>();
        stack.push(root);
        while(!stack.isEmpty()){
            Node tmpnode=stack.pop();
            if(tmpnode.true_children==null){
                if(tmpnode.false_children==null) {
                    StringBuilder sb=new StringBuilder(tmpnode.getID());
                    sb.append(" [label=\"");
                    if(tmpnode.candidates==null) {
                        sb.append("NULL");
                    }
                    else {
                        sb.append(tmpnode.candidates.toString());
                    }
                    sb.append("\"]");
                    candidates.add(sb.toString());
                }
                else{
                    stack.push(tmpnode.false_children);
                    nodes.add(tmpnode.getID()+" [label=\""+tmpnode.getTestAttribute()+"\"]");
                    links.add("\""+tmpnode.getID()+"\" -> \""+
                         tmpnode.false_children.getID()+"\" [label=\"no\"];");
                }
            }
            else{
                if(tmpnode.false_children==null){
                    stack.push(tmpnode.true_children);
                    nodes.add(tmpnode.getID()+" [label=\""+tmpnode.getTestAttribute()+"\"]");
                    links.add("\""+tmpnode.getID()+"\" -> \""+
                         tmpnode.true_children.getID()+"\" [label=\"yes\"];");
                }
                else{
                    stack.push(tmpnode.true_children);
                    stack.push(tmpnode.false_children);
                    nodes.add(tmpnode.getID()+" [label=\""+tmpnode.getTestAttribute()+"\"]");
                    links.add("\""+tmpnode.getID()+"\" -> \""+
                         tmpnode.false_children.getID()+"\" [label=\"no\"];");
                    links.add("\""+tmpnode.getID()+"\" -> \""+
                         tmpnode.true_children.getID()+"\" [label=\"yes\"];");
                }
            }
        }
        pw.println("digraph DecissionTree {");
        pw.print("node [shape=circle];  ");
        for(String s: nodes){
            pw.print(s);
            pw.print("; ");
        }
        pw.println();
        pw.print("node [shape=box];  ");
        for(String s: candidates){
            pw.print(s);
            pw.print("; ");
        }
        pw.println();
        for(String s: links){
            pw.println(s);
        }
        pw.println("}");
        if(empty){
            pw.close();
        }
    }
    
    /**
     * Method that computes the number of questions needed to get to the leave
     * containing a given candidate.
     * @param candidate Candidate stem/paradigm searched in the tree
     * @return Returns the number of questions needed to get to the leave
     * containing a given candidate
     * @throws NotInTreeException Exception thrown when the candidate searched
     * is not found in the tree
     */
    public int QuestionsToParadigm(Candidate candidate) throws NotInTreeException{
        int result=0;
        Node newnode=root;
        //loop going across all the tree in-order
        do{
            //If it is possible to go down to a false question children
            if(newnode.false_children!=null){
                newnode=newnode.false_children;
                result++;
            }
            else{
                //If not, if it is possible to go down to a true question children
                if(newnode.true_children!=null){
                    newnode=newnode.true_children;
                    result++;
                }
                else{
                    //If it is a leaf, checking if it is the one with the right paradigm
                    if(newnode.candidates!=null && newnode.candidates.contains(candidate)){
                        return result;
                    }
                    else{
                        if(newnode.getParent()==null){
                            throw new NotInTreeException();
                        }
                        else{
                            //If the current node is a false question children, we move to the true question one
                            if(newnode==newnode.getParent().false_children){
                                newnode=newnode.getParent().true_children;
                            }else{
                                //If it is a true children one, we look for the next parent which
                                //is a false false children and move to the true one in its level
                                while(newnode.getParent()!=null &&
                                        newnode==newnode.getParent().true_children){
                                    newnode=newnode.getParent();
                                    result--;
                                }
                                if(newnode.getParent()!=null){
                                    newnode=newnode.getParent().true_children;
                                }
                            }
                        }
                    }
                }
            }
        //if we get the root without finding the right paradigm, the method returns -1
        } while(newnode.getParent()!=null);
        return -1;
    }

    /**
     * Method that undoes the last accept/reject operation. Method that reverts
     * the last accept/reject decision so the current position in the tree is
     * moved to the immediately previous level, so the next surface form queried
     * to the oracle is the last one which was asked.
     */
    @Override
    public void GoBack() {
        ID3TreeDecision lastoperation=(ID3TreeDecision) this.operations.pop();
        this.current_position=lastoperation.parent;
    }

    /**
     * Method that accepts a given surface form from the possible surface forms
     * generated by the candidates in the current node of the ID3 tree. When a
     * surface form is accepted, the current node pointer is moved to the
     * corresponding descendent of the current ID3 node. Therefore, all the
     * paths in the tree assuming that the queried surface form is wrong are
     * discarded.
     * @param form Surface word form to be accepted
     */
    @Override
    public void AcceptForm(String form) {
        ID3TreeDecision id3decision=new ID3TreeDecision(false, form, this.current_position);
        this.operations.add(id3decision);
        this.current_position=this.current_position.true_children;
    }

    /**
     * Method that rejects a given surface form from the possible surface forms
     * generated by the candidates in the current node of the ID3 tree. When a
     * surface form is rejected, the current node pointer is moved to the 
     * corresponding descendent of the current ID3 node. Therefore, all the 
     * paths in the tree assuming that the queried surface form is correct are
     * discarded.
     * @param form Surface word form to be rejected
     */
    @Override
    public void RejectForm(String form) {
        ID3TreeDecision id3decision=new ID3TreeDecision(true, form, this.current_position);
        this.operations.add(id3decision);
        this.current_position=this.current_position.false_children;
    }

    /**
     * Method that returns the next surface form to be asked to a user in the
     * process of accepting/rejecting surface forms for a given set of candidates.
     * Method that returns a surface form to be asked to a user, in this case,
     * the one corresponding to the current node in the tree.
     * @return Returns the next surface form to be asked to a user in the process
     * of accepting/rejecting surface forms for a given set of candidates
     */
    @Override
    public String getNextSurfaceFormToAsk() {
        return this.current_position.getTestAttribute();
    }

    /**
     * Method that returns the plausible solution in a given moment of the
     * querying process. Method that returns the candidate which is a temporal 
     * solution for the system. In case that the current node is a leaf node,
     * the returned solution is the final solution of the process.
     * @return Returns the possible solution in a given moment of the querying
     * process
     */
    @Override
    public EquivalentCandidates getSolution() {
        return this.current_position.getCandidate();
    }
}
