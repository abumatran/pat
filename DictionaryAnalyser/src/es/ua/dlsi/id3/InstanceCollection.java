/**************************************************************************
 DictionaryAnalyser - Package based in DixTools and created to provide a set
               of tools that ease the addition of new entries to dictionaries
               and helps to analyse the dictionaries.

 Copyright (C) 2011-2012 Universitat d'Alacant [www.ua.es]

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 **************************************************************************/

package es.ua.dlsi.id3;

import dics.elements.dtd.Dictionary;
import es.ua.dlsi.monolingual.Candidate;
import es.ua.dlsi.monolingual.EquivalentCandidates;
import es.ua.dlsi.querying.RankedCandidate;
import java.io.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

/**
 * Class that represents a set of instances for building an ID3 tree.
 * @author Miquel Espl√† Gomis
 */
public class InstanceCollection {
    
    /** List with all the instances in the corpus */
    private List<Instance> instances;
    
    /** Set of surface forms that can be generated by the candidates in the
     * instance set */
    private List<String> surfaceforms;
    
    /** Set of candidates related to the instances */
    private Set<EquivalentCandidates> classes;
    
    /**
     * Default constructor.
     */
    public InstanceCollection(){
        instances=new ArrayList<Instance>();
        surfaceforms=new ArrayList<String>();
        classes=new HashSet<EquivalentCandidates>();
    }
    
    /**
     * Method that builds the set of instances by reading them from a text file.
     * @param file_path Path where the file is placed
     */
    public void buildInstances(String file_path) {
        BufferedReader reader;
        DataInputStream dis = null;

        try {
            File f = new File(file_path);
            FileInputStream fis = new FileInputStream(f);
            reader = new BufferedReader(new InputStreamReader(fis));

            // read the first record of the file
            String line;
            Instance i;
            List<Boolean> attributes;
            line = reader.readLine();
            String[] st = line.split(",");
            int at_count;
            for(at_count=0;at_count<st.length-1;at_count++){
                this.surfaceforms.add(st[at_count]);
            }
            while ((line = reader.readLine()) != null) {
                st = line.split(",");
                attributes = new ArrayList<Boolean>();
                for(at_count=0;at_count<st.length-1;at_count++){
                    attributes.add(Boolean.parseBoolean(st[at_count]));
                }
                EquivalentCandidates ec=null;
                if(st[at_count].contains(";")){
                    String[] candidates_string=st[at_count].split(";");
                    for(String c : candidates_string){
                        String[] candidate=c.split("\\|");
                        Candidate newcandidate=new Candidate(candidate[0], candidate[1]);
                        if(ec==null){
                            ec=new EquivalentCandidates(newcandidate);
                        }
                        else{
                            ec.addCandidate(newcandidate);
                        }
                    }
                }
                else{
                    String[] candidate=st[at_count].split("\\|");
                    Candidate tmpc=new Candidate(candidate[0], candidate[1]);
                    ec=new EquivalentCandidates(tmpc);
                }
                i = new Instance(attributes,ec);
                AddInstance(i);
            }
        }
        catch (IOException e) {
            //System.out.println("Uh oh, got an IOException error: " + e.getMessage());
            e.printStackTrace(System.err);
            System.exit(-1);
        }
        catch (Exception e) {
            //System.out.println("Uh oh, got an Exception error: " + e.getMessage());
            e.printStackTrace(System.err);
            System.exit(-1);
        }
        finally {
            if (dis != null) {
                try {
                    dis.close();
                } catch (IOException ioe) {
                    ioe.printStackTrace(System.err);
                }
            }
        }
    }
    
    /**
     * Method that builds the collection of instances from a set of all the
     * possible surface forms in the whole instance collection, a set of
     * candidates, and a dictionary
     * @param possiblesurfaceforms Set of all the possible surface forms generated
     * by all the candidates in the instance collection
     * @param sf_candidate set of candidates in the collection
     * @param dic Apertium dictionary where the candidate can be found
     */
    public void buildInstances(Set<String> possiblesurfaceforms,
            Set<EquivalentCandidates> sf_candidate, Dictionary dic) {
        Instance i;
        List<Boolean> attributes;
        double total_prob=0.0;
        this.surfaceforms.addAll(possiblesurfaceforms);
        for(EquivalentCandidates qc: sf_candidate){
            attributes=new LinkedList<Boolean>();
            for(String s: this.surfaceforms){
                if(qc.getSurfaceForms(dic).contains(s)) {
                    attributes.add(Boolean.TRUE);
                }
                else {
                    attributes.add(Boolean.FALSE);
                }
            }
            if(qc instanceof RankedCandidate){
                double prob=((RankedCandidate)qc).getScore();
                i = new Instance(attributes,qc,((RankedCandidate)qc).getScore());
                if(prob==0) {
                    total_prob+=Entropy.minimum_probability;
                }
                else {
                    total_prob+=((RankedCandidate)qc).getScore();
                }
            }
            else{
                i = new Instance(attributes,qc);
                total_prob++;
            }
            this.classes.add(qc);
            AddInstance(i);
        }
        for(Instance instance: this.instances){
            double prev_prob=instance.GetProbability();
            instance.SetProbability(prev_prob/total_prob);
        }
    }
    
    /**
     * Method that adds a new instance to the collection.
     * @param i New instance to the collection
     */
    private void AddInstance(Instance i){
        instances.add(i);
        classes.add(i.getInstanceClass());
    }
    
    /**
     * Method that returns the set of instances in the collection.
     * @return Returns the set of instances in the collection
     */
    public List<Instance> getInstances(){
        return instances;
    }
    
    /**
     * Method that returns the set of instances.
     * @return Returns the set of instances
     */
    public Set<EquivalentCandidates> getInstanceClasses(){
        return classes;
    }
    
    /**
     * Method that returns the number of classes (candidates).
     * @return Returns the number of classes (candidates)
     */
    public int getNumClasses(){
        return classes.size();
    }
    
    /**
     * Method that returns <code>true</code> if the set of instances is empty and
     * <code>false</code> otherwise.
     * @return Returns <code>true</code> if the set of instances is empty and
     * <code>false</code> otherwise
     */
    public boolean isEmpty(){
        return instances.isEmpty();
    }
    
    /**
     * Method that returns the surface forms that can be generated by the set of
     * candidates in the instances collection.
     * @return Returns the surface forms that can be generated by the set of
     * candidates in the instances collection
     */
    public List<String> getSurfaceForms(){
        return surfaceforms;
    }
    
    /**
     * Method that returns the number of surface forms that can be generated by
     * the set of candidates in the instances collection.
     * @return Returns the number of surface forms that can be generated by the
     * set of candidates in the instances collection
     */
    public int getNumSurfaceForms(){
        return surfaceforms.size();
    }
    
    /**
     * Method that returns a sub-set of the instances collection by using a test
     * attribute. This method splits the initial collection of instances by
     * creating a sub-set which contains a given attribute (postive-test) and a
     * sub-set that does not contain it (negative-test) and returns one of these
     * sub-sets.
     * @param attr Attribute to be used to generate the sub-set
     * @param value Value chosen for determining the sub-set to be returned
     * @return Returns a sub-set of instances depending; depending on the value
     * chosen, it can be the one not containing the attribute or the one
     * containing it
     */
    public InstanceCollection subset(int attr, boolean value) {
        InstanceCollection subset = new InstanceCollection();
        subset.surfaceforms=this.surfaceforms;

        for(Instance record: this.instances) {
            if(record.getAttributes().get(attr) == value) {
                subset.AddInstance(record);
            }
        }
        return subset;
    }
}
