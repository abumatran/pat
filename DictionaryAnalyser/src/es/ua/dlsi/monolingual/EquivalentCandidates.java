/**************************************************************************
 DictionaryAnalyser - Package based in DixTools and created to provide a set
               of tools that ease the addition of new entries to dictionaries
               and helps to analyse the dictionaries.

 Copyright (C) 2011-2012 Universitat d'Alacant [www.ua.es]

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 **************************************************************************/

package es.ua.dlsi.monolingual;

import dics.elements.dtd.Dictionary;
import java.util.LinkedHashSet;
import java.util.Set;

/**
 * Class that represents a set of candidates stem/paradigm that generate the same
 * set of surface forms when inflected.
 * @author Miquel Espl√† Gomis
 */
public class EquivalentCandidates {
    
    /** Set of candidates generating the same surface form set when inflected. */
    protected Set<Candidate> equivalent_candidates;
    
    /** Set of surface forms generated. */
    protected Set<String> surfaceforms;

    /** Overloaded constructor creating the object from a set of candidates. */
    public EquivalentCandidates(Set<Candidate> candidates) {
        this.equivalent_candidates=candidates;
        this.surfaceforms=null;
    }
    
    /** Overloaded constructor creating the object from an only candidate. */
    public EquivalentCandidates(Candidate candidate) {
        this.equivalent_candidates=new LinkedHashSet<Candidate>();
        this.equivalent_candidates.add(candidate);
        this.surfaceforms=null;
    }
    
    /**
     * Method that returns the set of candidates in the object.
     * @return Returns the set of candidates in the object
     */
    public Set<Candidate> getCandidates(){
        return equivalent_candidates;
    }
    
    /**
     * Method that adds a new candidate to the set.
     * @param c New candidate to be added to the set
     */
    public void addCandidate(Candidate c){
        this.equivalent_candidates.add(c);
    }

    /**
     * Method that returns the set of surface forms generated by the paradigms
     * in the object.
     * @param dic Dictionary containing the inflection information
     * @return Returns the set of surface forms generated by the paradigms
     * in the object
     */
    public Set<String> getSurfaceForms(Dictionary dic) {
        if(this.surfaceforms==null){
            this.surfaceforms=this.equivalent_candidates.iterator().next().GetSurfaceForms(dic);
        }
        return surfaceforms;
    }

    /**
     * Method that computes a hash code from the variables in the object.
     * @return Returns the hash code computed
     */
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 11 * hash + (this.equivalent_candidates != null ? this.equivalent_candidates.hashCode() : 0);
        return hash;
    }

    /**
     * Method that compares two <code>EquivalentCandidates</code> objects by
     * comparing the equivalent candidates. Method that compares two
     * <code>EquivalentCandidates</code> objects by comparing the equivalent
     * candidates
     * @param obj The object to compare with the current object
     * @return Returns <code>true</code> if the two objects are equal and
     * <code>false</code> otherwise
     */
    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final EquivalentCandidates other = (EquivalentCandidates) obj;
        if (this.equivalent_candidates != other.equivalent_candidates && (this.equivalent_candidates == null || !this.equivalent_candidates.equals(other.equivalent_candidates))) {
            return false;
        }
        return true;
    }
    
    /**
     * Method returns a string representing the candidate, containing the list 
     * of equivalent stem/paradigms. Method returns a string representing the
     * candidate, containing the list of equivalent stem/paradigms
     * @return Returns a string representing the candidate, containing the list
     * of equivalent stem/paradigms
     */
    @Override
    public String toString(){
        StringBuilder sb=new StringBuilder();
        for(Candidate c: this.equivalent_candidates){
            sb.append(c.toString());
            sb.append(";");
        }
        sb.deleteCharAt(sb.length()-1);
        return sb.toString();
    }
    
    /**
     * Method that returns <code>true</code> when the set contains a given 
     * candidate and false otherwise.
     * @param c Candidate to be checked
     * @return Returns <code>true</code> when the set contains a given candidate
     * and false otherwise
     */
    public boolean contains(Candidate c){
        return this.getCandidates().contains(c);
    }
}
